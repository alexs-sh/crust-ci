# -*- python -*-
# ex: set filetype=python:

from buildbot.plugins import *

####### Описание
# Для примера настроен 1 мастер -> 1 воркер ->1 билдер без параллельного выполнения задач.
# Эта комбинация весьма проста и не тербовательна к ресурсам, что делает
# ее идеальной для примера
# Мастер - отслеживает изменения репозитория или команды от пользователя.
# Воркер - получает команды от мастера и передает билдерам. Он связан с конкретной версией ядра
# Билдер - непосредственно выполняет задачу. Он связан с конкертной версией девайса
# Т.о.
# 1 Master -> N Worker, где каждый воркер отвечает за свою ветку ядра
# 1 Worker -> N Builder, где каждый билдер отвечает за свое устройство
# Для запуска сборки используются два триггера:
#    - изменение в репозитории
#    - команда от пользователя
# За обработку каждго из этих событий отвечют планировщищки

####### Параметры для конфигурации
WORKER_NAME='kworker'
WORKER_PASS='nopass'
WORKER_CONCURRENCY=1

BUILDER_NAME='linux-4-14-imx6ull-nano'
BUILDER_CONFIG='imx6ull_nano_defconfig'

KERNEL_REPO='https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git'
KERNEL_BRANCH='linux-4.14.y'
KERNEL_CONFIGS_REPO='git@bitbucket.org:alexsteam4000/crust-kernel.git'
OUTPUT_DIR='/tmp/crust-ci/linux-4.14.y/'
BUILDBOT_HOST='127.0.0.1'
BUILDBOT_PORT=8010


####### Настройка Buildbot
c = BuildmasterConfig = {}

####### Настройка воркера
# Для примера настроен 1 воркер

c['workers']=[]
c['workers'].append(worker.Worker(WORKER_NAME, WORKER_PASS, max_builds=WORKER_CONCURRENCY))
c['protocols'] = {'pb': {'port': 9989}}

####### Репозиторий для отслеживания изменений
c['change_source'] = []
c['change_source'].append(changes.GitPoller(
        KERNEL_REPO,
        workdir='gitpoller-workdir', branch=KERNEL_BRANCH,
        pollInterval=300))

####### Планировщики
c['schedulers'] = []
c['schedulers'].append(schedulers.SingleBranchScheduler(
                            name='Changes',
                            change_filter=util.ChangeFilter(branch=KERNEL_BRANCH),
                            treeStableTimer=None,
                            builderNames=[BUILDER_NAME]))

c['schedulers'].append(schedulers.ForceScheduler(
                            name='Force',
                            builderNames=[BUILDER_NAME]))

#######  Самое интересное - шаги в сборке
def build_kernel(repo,branch,config,out):
    """
    repo - url репозитория ядра
    branch - имя ветки ядра
    config - имя конфига buildroot'а, который должен быть собран
    """
    buildroot_name = 'buildroot-2018.02.6'
    factory = util.BuildFactory()
    factory.addStep(steps.ShellCommand(name='Cleanup', command='rm -rf * && rm -rf {0}'.format(out)))
    factory.addStep(steps.ShellCommand(name='Download Buildroot', command='wget https://buildroot.org/downloads/{}.tar.gz'.format(buildroot_name)))
    factory.addStep(steps.ShellCommand(name='Download Crust', command='git clone --single-branch -b {0} --depth 1 {1}'.format(branch, repo)))
    factory.addStep(steps.ShellCommand(name='Unpack Buildroot', command='tar xvf {0}.tar.gz && mv {0} buildroot'.format(buildroot_name)))
    factory.addStep(steps.ShellCommand(name='Add configs', command='cp -rf crust-kernel/freescale/imx6ull_nano/* ./buildroot'))
    factory.addStep(steps.ShellCommand(name='Build', command='cd buildroot && make {0} && make'.format(config)))
    factory.addStep(steps.ShellCommand(name='Generate info', command='tar cvf buildroot/output/images/configs.tar crust-kernel/freescale/imx6ull_nano/ &&\
									ls buildroot/dl > buildroot/output/images/packages &&\
									cd buildroot/output/images/ &&\
									md5sum * | tee checksums'))
    factory.addStep(steps.ShellCommand(name='Output', command='mkdir -p {0} && cp -r buildroot/output/images/* {0}'.format(out)))
    return factory

c['builders'] = []
c['builders'].append(
    util.BuilderConfig(name=BUILDER_NAME,
      workernames=[WORKER_NAME],
      factory=build_kernel(KERNEL_CONFIGS_REPO, KERNEL_BRANCH, BUILDER_CONFIG, OUTPUT_DIR)))

c['services'] = []

####### Названия / имена / красивости
c['title'] = 'Kernel Bot'
c['buildbotURL'] = 'http://{0}:{1}/'.format(BUILDBOT_HOST, BUILDBOT_PORT)

# Настройка WEB-морды
c['www'] = dict(port=BUILDBOT_PORT,
                plugins=dict(waterfall_view={}, console_view={}, grid_view={}))

####### Настройка БД для хранения результатов

c['db'] = {
    'db_url' : "sqlite:///state.sqlite",
}
